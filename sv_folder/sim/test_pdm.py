import cocotb
import os
import random
import sys
from math import log
import logging
from pathlib import Path
from cocotb.clock import Clock
from cocotb.triggers import Timer, ClockCycles, RisingEdge, FallingEdge, ReadOnly,with_timeout
from cocotb.utils import get_sim_time as gst
from cocotb.runner import get_runner
import numpy as np

import matplotlib.pyplot as plt
import scipy

# Global Constants
SAMPLE_RATE = 31250  # Audio sample rate in Hz
OVERSAMPLE_RATE = 128 * SAMPLE_RATE  # PDM clock frequency
DURATION = 0.001  # Test duration in seconds (5 ms)
AMPLITUDE = (2**23) - 1  # Max amplitude for 24-bit signed audio
FREQUENCY = 1000  # 1 kHz sine wave

@cocotb.coroutine
async def clock_divider(clock, divider, trigger_signal):
    """
    Clock divider coroutine.
    """
    count = 0
    while True:
        await RisingEdge(clock)  # Wait for a rising edge of the input clock
        if count == divider-1:
            count = 0
            trigger_signal.value = 1 if trigger_signal.value == 0 else 0  # Toggle the tri
        else:
            #trigger_signal.value =  0
            count+=1

# Helper function to generate a sine wave
def generate_sine_wave(amplitude, frequency, sample_rate, duration, plot = False):
    """Generate a sine wave with specified parameters."""
    t = np.arange(0, duration, 1 / sample_rate)
    sine_wave = amplitude * np.sin(2 * np.pi * frequency * t)
    if plot:
        plt.figure(figsize=(8, 4))
        plt.plot(t, sine_wave, label="Sine Wave", color="blue")
        plt.title("Generated Sine Wave")
        plt.xlabel("Time (s)")
        plt.ylabel("Amplitude")
        plt.grid(True)
        plt.legend()
        plt.tight_layout()
        plt.savefig("sine_wave.png")
        plt.close()
        #plt.show()
    return sine_wave.astype(np.int32)

def plot_results(pdm_output, sine_wave, time_axis, duration = DURATION, amplitude = AMPLITUDE):
    """
    Saves pdm_vs_input.png file to sim_build directory
    params:
    pdm_output - list of pdm output bits (1/0s)
    sine_wave - np array generated by generate_sine_wave
    time_axis - np array for the plots time axis
    duration - duration of sine wave
    amplitude - max amplitude of sine wave
    """
    # basically like applying a low pass filter, this will give us a better visual rep for what it will sound like
    window_size = 128  # A larger window size for better smoothing
    filtered_pdm_output = np.convolve(pdm_output, np.ones(window_size)/window_size, mode='same') -.5 # go down .5 so graphs overlap better

    # interpolate the sine wave so it matches shape with the pdm
    interp_func = scipy.interpolate.interp1d(np.linspace(0, duration, len(sine_wave)), sine_wave, kind='linear')
    interpolated_sine_wave = interp_func(time_axis)

    # Plot and save the PDM output overlayed with the audio input
    plt.figure(figsize=(10, 5))
    plt.plot(time_axis, interpolated_sine_wave / amplitude, label="Interpolated Normalized Sine Wave", color="blue", linewidth=1.5)
    plt.plot(time_axis, filtered_pdm_output, label="Filtered PDM Output", color="orange", alpha=0.6)
    plt.title("PDM Output Overlayed with Audio Input")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("pdm_vs_input.png")
    
    cocotb.log.info("Plot saved as pdm_vs_input.png")
    plt.close()


@cocotb.test()
async def test_pdm_modulator(dut):
    """Test the PDM modulator with various inputs."""

    # Create a 1 MHz clock (example clock frequency, adjust to match your module)
    cocotb.start_soon(Clock(dut.clk_in, 10, units="ns").start())


    # Start the clock divider coroutine
    cocotb.start_soon(clock_divider(dut.clk_in, 25, dut.sample_in))

    # Reset the DUT
    dut.rst_in.value = 1
    await RisingEdge(dut.clk_in)  # Wait for 1 clock edge
    await FallingEdge(dut.clk_in)
    dut.rst_in.value = 0

    # Generate test data: a sine wave
    sine_wave = generate_sine_wave(AMPLITUDE, FREQUENCY, SAMPLE_RATE, DURATION)

    # Initialize variables
    total_high = 0
    total_samples = len(sine_wave) * OVERSAMPLE_RATE // SAMPLE_RATE
    pdm_output = []  # Collect the PDM output for plotting
    time_axis = np.linspace(0, DURATION, total_samples)  # Time axis for plotting

    # Feed the sine wave into the DUT
    for i, sample in enumerate(sine_wave):
        for _ in range(OVERSAMPLE_RATE // SAMPLE_RATE):
            dut.audio_in.value = int(sample)
            await RisingEdge(dut.sample_in)

            # Collect PDM output
            pdm_output.append(dut.pdm_out.value.integer)
            total_high += dut.pdm_out.value.integer

        # Print progress for debugging
        if i % 10 == 0:
            cocotb.log.info(f"Processed {i} audio samples out of {len(sine_wave)}")

    # Analyze results
    pdm_density = total_high / total_samples
    expected_density = np.mean((sine_wave / AMPLITUDE) * 0.5 + .5)

    plot_results(pdm_output,sine_wave,time_axis)

    # Check that the PDM density matches the input signal
    assert abs(pdm_density - expected_density) < 0.01, (
        f"PDM density {pdm_density} deviates from expected density {expected_density}"
    )
    cocotb.log.info(f"PDM density test passed: {pdm_density:.4f}")


def pdm_runner():
    """Simulate the tdm receiver using the Python runner."""
    hdl_toplevel_lang = os.getenv("HDL_TOPLEVEL_LANG", "verilog")
    sim = os.getenv("SIM", "icarus")
    proj_path = Path(__file__).resolve().parent.parent
    sys.path.append(str(proj_path / "sim" / "model"))
    sources = [proj_path / "hdl" / "pdm.sv"]
    build_test_args = ["-Wall"]
    parameters = {'BIT_WIDTH': 24} #!!!change these to do different versions
    sys.path.append(str(proj_path / "sim"))
    runner = get_runner(sim)
    runner.build(
        sources=sources,
        hdl_toplevel="pdm",
        always=True,
        build_args=build_test_args,
        parameters=parameters,
        timescale = ('1ns','1ps'),
        waves=True
    )
    run_test_args = []
    runner.test(
        hdl_toplevel="pdm",
        test_module="test_pdm",
        test_args=run_test_args,
        waves=True
    )


if __name__ == "__main__":
     # Constants
    SAMPLE_RATE = 40000  # Audio sample rate in Hz
    OVERSAMPLE_RATE = 64 * SAMPLE_RATE  # PDM clock frequency
    DURATION = 0.005  # Test duration in seconds (10 ms)
    AMPLITUDE = (2**23) - 1  # Max amplitude for 24-bit signed audio
    FREQUENCY = 1000  # 1 kHz sine wave
    #sine_wave = generate_sine_wave(AMPLITUDE, FREQUENCY, SAMPLE_RATE, DURATION,plot=True)
    pdm_runner()
